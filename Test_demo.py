import mysql.connector
import json
import joblib
import re
import logging
from typing import Dict, Optional, Tuple
from contextlib import contextmanager
from sentence_transformers import SentenceTransformer
from langchain.chains import LLMChain
from langchain.prompts import PromptTemplate
from langchain.llms import Ollama
from fuzzywuzzy import process

# Setup logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# ------------------------
# Configuration
# ------------------------
DB_CONFIG = {
    "host": "localhost",
    "user": "root",
    "password": "17101975",  # Consider using environment variables
    "database": "bookstore"
}

FUZZY_MATCH_THRESHOLD = 70
DEFAULT_CUSTOMER_NAME = "Kh√°ch h√†ng"

# ------------------------
# 1. Load models with error handling
# ------------------------
try:
    embed_model = SentenceTransformer('sentence-transformers/paraphrase-multilingual-MiniLM-L12-v2')
    clf = joblib.load("model/model_xgb.pkl")
    label_encoder = joblib.load("model/label_encoder.pkl")
    logger.info("Models loaded successfully")
except Exception as e:
    logger.error(f"Error loading models: {e}")
    raise


def classify_intent(user_input: str) -> str:
    """Classify user intent using pre-trained model."""
    try:
        emb = embed_model.encode([user_input])
        pred_label = clf.predict(emb)[0]
        intent = label_encoder.inverse_transform([pred_label])[0]
        return intent
    except Exception as e:
        logger.error(f"Error classifying intent: {e}")
        return "unknown"


# ------------------------
# 2. Improved database connection with context manager
# ------------------------
@contextmanager
def get_db_connection():
    """Context manager for database connections."""
    conn = None
    try:
        conn = mysql.connector.connect(**DB_CONFIG)
        yield conn
    except mysql.connector.Error as e:
        logger.error(f"Database error: {e}")
        if conn:
            conn.rollback()
        raise
    finally:
        if conn:
            conn.close()


# ------------------------
# 3. Improved book lookup
# ------------------------
def extract_book_title(user_input: str) -> str:
    """Extract book title from user input using improved regex."""
    patterns = [
        r'(?:cu·ªën|quy·ªÉn|s√°ch)?\s*(.+?)(?:\s*(?:gi√°|c√≤n|t·∫≠p|th√¥ng tin|,|$))',
        r'(.+?)(?:\s*(?:nh∆∞ th·∫ø n√†o|ra sao|bao nhi√™u|$))',
        r'(?:t√¨m|xem|ki·∫øm)\s+(.+)',
    ]

    for pattern in patterns:
        match = re.search(pattern, user_input.strip(), re.IGNORECASE)
        if match:
            title = match.group(1).strip()
            if title and len(title) > 1:
                return title

    return user_input.strip()


def lookup_book(book_title: str) -> str:
    """Look up book information in database."""
    try:
        with get_db_connection() as conn:
            cursor = conn.cursor()
            query = """
                SELECT title, author, price, stock, category 
                FROM books 
                WHERE title LIKE %s 
                ORDER BY title
            """
            cursor.execute(query, (f"%{book_title}%",))
            results = cursor.fetchall()

            if results:
                responses = []
                for title, author, price, stock, category in results:
                    stock_status = "c√≤n h√†ng" if stock > 0 else "h·∫øt h√†ng"
                    response = (f"üìö {title}\n"
                                f"   T√°c gi·∫£: {author}\n"
                                f"   Gi√°: {price:,.0f} VNƒê\n"
                                f"   T·ªìn kho: {stock} quy·ªÉn ({stock_status})\n"
                                f"   Th·ªÉ lo·∫°i: {category}\n")
                    responses.append(response)
                return "\n".join(responses)
            else:
                return f"‚ùå Kh√¥ng t√¨m th·∫•y s√°ch v·ªõi t·ª´ kh√≥a '{book_title}'."

    except Exception as e:
        logger.error(f"Error looking up book: {e}")
        return "L·ªói khi t√¨m ki·∫øm s√°ch. Vui l√≤ng th·ª≠ l·∫°i."


# ------------------------
# 4. Enhanced LLM entity extraction
# ------------------------
llm = Ollama(model="llama3.2:1b")
entity_prompt = PromptTemplate(
    input_variables=["user_input"],
    template="""Tr√≠ch xu·∫•t th√¥ng tin ƒë·∫∑t h√†ng t·ª´ c√¢u sau v√† tr·∫£ v·ªÅ JSON:
{{"book_title": "t√™n s√°ch", "quantity": s·ªë_l∆∞·ª£ng, "address": "ƒë·ªãa ch·ªâ", "phone": "s·ªë ƒëi·ªán tho·∫°i"}}

C√¢u: {user_input}

JSON:"""
)
entity_chain = LLMChain(llm=llm, prompt=entity_prompt)


def extract_order_entities(user_input: str) -> Dict[str, any]:
    """Extract order entities using LLM with regex fallback."""
    try:
        # Try LLM extraction first
        response = entity_chain.invoke({"user_input": user_input})
        json_str = response["text"] if isinstance(response, dict) else response

        # Clean the response
        json_str = json_str.strip()
        if json_str.startswith("```json"):
            json_str = json_str[7:]
        if json_str.endswith("```"):
            json_str = json_str[:-3]

        order = json.loads(json_str)

        # Validate and clean extracted data
        return {
            "book_title": str(order.get("book_title") or "").strip().rstrip(",."),
            "quantity": max(1, int(order.get("quantity") or 1)),
            "address": str(order.get("address") or "Unknown").strip().rstrip(",."),
            "phone": str(order.get("phone") or "Unknown").strip().rstrip(",.")
        }

    except Exception as e:
        logger.warning(f"LLM extraction failed: {e}, falling back to regex")
        return extract_order_entities_regex(user_input)


def extract_order_entities_regex(user_input: str) -> Dict[str, any]:
    """Fallback regex-based entity extraction."""
    # Extract phone number
    phone_patterns = [
        r'(?:s·ªë ƒëi·ªán tho·∫°i|sƒët|ƒët|phone)[:\s]*([\d\s\-]{8,15})',
        r'(\b(?:0[1-9]|84[1-9])[\d\s\-]{7,11}\b)'
    ]
    phone = "Unknown"
    for pattern in phone_patterns:
        match = re.search(pattern, user_input, re.IGNORECASE)
        if match:
            phone = re.sub(r'[\s\-]', '', match.group(1))
            break

    # Remove phone from input for cleaner address extraction
    temp_input = user_input
    for pattern in phone_patterns:
        temp_input = re.sub(pattern, '', temp_input, flags=re.IGNORECASE)

    # Extract address
    addr_patterns = [
        r'(?:giao|t·ªõi|ƒë·∫øn|v·ªÅ|ƒë·ªãa ch·ªâ|·ªü)\s+([^,\d]*(?:[^\d,]*[a-zA-Z√†√°·∫£√£·∫°ƒÉ·∫Ø·∫±·∫≥·∫µ·∫∑√¢·∫•·∫ß·∫©·∫´·∫≠√®√©·∫ª·∫Ω·∫π√™·∫ø·ªÅ·ªÉ·ªÖ·ªáƒë√¨√≠·ªâƒ©·ªã√≤√≥·ªè√µ·ªç√¥·ªë·ªì·ªï·ªó·ªô∆°·ªõ·ªù·ªü·ª°·ª£√π√∫·ªß≈©·ª•∆∞·ª©·ª´·ª≠·ªØ·ª±·ª≥√Ω·ª∑·ªπ·ªµ][^,]*)*)',
        r'([a-zA-Z√†√°·∫£√£·∫°ƒÉ·∫Ø·∫±·∫≥·∫µ·∫∑√¢·∫•·∫ß·∫©·∫´·∫≠√®√©·∫ª·∫Ω·∫π√™·∫ø·ªÅ·ªÉ·ªÖ·ªáƒë√¨√≠·ªâƒ©·ªã√≤√≥·ªè√µ·ªç√¥·ªë·ªì·ªï·ªó·ªô∆°·ªõ·ªù·ªü·ª°·ª£√π√∫·ªß≈©·ª•∆∞·ª©·ª´·ª≠·ªØ·ª±·ª≥√Ω·ª∑·ªπ·ªµ\s,]+(?:qu·∫≠n|huy·ªán|ph∆∞·ªùng|x√£|th√†nh ph·ªë|t·ªânh)[^,]*)'
    ]
    address = "Unknown"
    for pattern in addr_patterns:
        match = re.search(pattern, temp_input, re.IGNORECASE)
        if match:
            address = match.group(1).strip().rstrip(",.")
            break

    # Extract quantity
    qty_match = re.search(r'(\d+)\s*(?:cu·ªën|quy·ªÉn|b·∫£n|c√°i)?', user_input, re.IGNORECASE)
    quantity = int(qty_match.group(1)) if qty_match else 1

    # Extract book title
    book_patterns = [
        r'(?:mua|ƒë·∫∑t|order)\s*(?:\d+)?\s*(?:cu·ªën|quy·ªÉn)?\s*(.+?)(?=\s*(?:giao|t·ªõi|ƒë·∫øn|v·ªÅ|ƒë·ªãa ch·ªâ|s·ªë ƒëi·ªán tho·∫°i)|$)',
        r'(?:cu·ªën|quy·ªÉn|s√°ch)\s+(.+?)(?=\s*(?:giao|t·ªõi|ƒë·∫øn|v·ªÅ)|$)',
        r'^(.+?)(?=\s*(?:\d+\s*(?:cu·ªën|quy·ªÉn))|(?:giao|t·ªõi|ƒë·∫øn)|$)'
    ]
    book_title = "Unknown"
    for pattern in book_patterns:
        match = re.search(pattern, temp_input.strip(), re.IGNORECASE)
        if match:
            title = match.group(1).strip().rstrip(",.")
            if title and len(title) > 2:
                book_title = title
                break

    return {
        "book_title": book_title,
        "quantity": quantity,
        "address": address,
        "phone": phone
    }


# ------------------------
# 5. Enhanced order placement
# ------------------------
def find_book_by_title(cursor, book_title: str) -> Optional[Tuple]:
    """Find book using exact match, fuzzy matching, and partial matching."""
    # 1. Exact match (case insensitive)
    cursor.execute(
        "SELECT book_id, title, stock, price FROM books WHERE LOWER(title) = LOWER(%s)",
        (book_title,)
    )
    result = cursor.fetchone()
    if result:
        return result, 100  # Perfect match score

    # 2. Partial match with LIKE
    cursor.execute(
        "SELECT book_id, title, stock, price FROM books WHERE LOWER(title) LIKE %s",
        (f"%{book_title.lower()}%",)
    )
    result = cursor.fetchone()
    if result:
        return result, 90  # High confidence

    # 3. Fuzzy matching
    cursor.execute("SELECT book_id, title, stock, price FROM books")
    all_books = cursor.fetchall()

    if all_books:
        titles = [book[1] for book in all_books]
        best_match, score = process.extractOne(book_title, titles)

        if score >= FUZZY_MATCH_THRESHOLD:
            for book in all_books:
                if book[1] == best_match:
                    return book, score

    return None, 0


def place_order(order: Dict[str, any], customer_name: str = DEFAULT_CUSTOMER_NAME) -> str:
    """Place an order with improved error handling and validation."""
    try:
        with get_db_connection() as conn:
            cursor = conn.cursor()

            book_title = order['book_title'].strip()
            if not book_title or book_title == "Unknown":
                return "‚ùå Kh√¥ng th·ªÉ x√°c ƒë·ªãnh t√™n s√°ch. Vui l√≤ng cung c·∫•p t√™n s√°ch c·ª• th·ªÉ."

            # Find book
            book_info, confidence = find_book_by_title(cursor, book_title)
            if not book_info:
                return f"‚ùå Kh√¥ng t√¨m th·∫•y s√°ch '{book_title}' trong kho."

            book_id, matched_title, stock, price = book_info

            # Validate stock
            if order["quantity"] > stock:
                return (f"‚ùå S√°ch '{matched_title}' ch·ªâ c√≤n {stock} quy·ªÉn, "
                        f"kh√¥ng ƒë·ªß s·ªë l∆∞·ª£ng {order['quantity']} quy·ªÉn y√™u c·∫ßu.")

            # Validate required fields
            if order["address"] == "Unknown":
                return "‚ùå Vui l√≤ng cung c·∫•p ƒë·ªãa ch·ªâ giao h√†ng."

            if order["phone"] == "Unknown":
                return "‚ùå Vui l√≤ng cung c·∫•p s·ªë ƒëi·ªán tho·∫°i li√™n h·ªá."

            # Calculate total
            total_amount = price * order["quantity"]

            # Insert order (without total_amount if column doesn't exist)
            cursor.execute("""
                INSERT INTO orders (customer_name, phone, address, book_id, quantity, status)
                VALUES (%s, %s, %s, %s, %s, %s)
            """, (customer_name, order["phone"], order["address"], book_id, order["quantity"], "pending"))

            # Update stock
            cursor.execute("""
                UPDATE books SET stock = stock - %s WHERE book_id = %s
            """, (order["quantity"], book_id))

            conn.commit()
            order_id = cursor.lastrowid

            # Generate success message
            confidence_msg = f" (ƒë·ªô kh·ªõp: {confidence}%)" if confidence < 100 else ""
            return (f"‚úÖ ƒê∆°n h√†ng #{order_id} ƒë√£ ƒë∆∞·ª£c t·∫°o th√†nh c√¥ng!\n"
                    f"üìö S√°ch: {matched_title}{confidence_msg}\n"
                    f"üì¶ S·ªë l∆∞·ª£ng: {order['quantity']} quy·ªÉn\n"
                    f"üí∞ T·ªïng ti·ªÅn: {total_amount:,.0f} VNƒê\n"
                    f"üìç Giao t·ªõi: {order['address']}\n"
                    f"üìû Li√™n h·ªá: {order['phone']}")

    except Exception as e:
        logger.error(f"Error placing order: {e}")
        return "‚ùå L·ªói khi ƒë·∫∑t h√†ng. Vui l√≤ng th·ª≠ l·∫°i sau."


# ------------------------
# 6. Enhanced main pipeline
# ------------------------
def process_user_input(user_input: str, customer_name: str = DEFAULT_CUSTOMER_NAME) -> str:
    """Process user input through the chatbot pipeline."""
    if not user_input.strip():
        return "Vui l√≤ng nh·∫≠p c√¢u h·ªèi ho·∫∑c y√™u c·∫ßu c·ªßa b·∫°n."

    try:
        intent = classify_intent(user_input)
        logger.info(f"Detected intent: {intent} for input: {user_input}")

        if intent == "detail_book":
            book_title = extract_book_title(user_input)
            return lookup_book(book_title)

        elif intent == "place_order":
            order = extract_order_entities(user_input)
            return place_order(order, customer_name)

        else:
            return (f"ü§î T√¥i ch∆∞a hi·ªÉu √Ω b·∫°n (intent: {intent}). "
                    f"B·∫°n c√≥ th·ªÉ h·ªèi v·ªÅ th√¥ng tin s√°ch ho·∫∑c ƒë·∫∑t h√†ng kh√¥ng?")

    except Exception as e:
        logger.error(f"Error processing user input: {e}")
        return "‚ùå ƒê√£ x·∫£y ra l·ªói. Vui l√≤ng th·ª≠ l·∫°i."


# ------------------------
# 7. Enhanced demo with better UX
# ------------------------
if __name__ == "__main__":
    print("ü§ñ Ch√†o m·ª´ng ƒë·∫øn v·ªõi Chatbot Nh√† S√°ch!")
    print("üí° B·∫°n c√≥ th·ªÉ:")
    print("   - H·ªèi th√¥ng tin s√°ch: 'S√°ch Python c√≥ kh√¥ng?'")
    print("   - ƒê·∫∑t h√†ng: 'Mua 2 cu·ªën Python giao 123 ABC, sƒët 0912345678'")
    print("   - G√µ 'exit' ƒë·ªÉ tho√°t\n")

    while True:
        try:
            user_input = input("üßë B·∫°n: ").strip()
            if user_input.lower() in ["exit", "quit", "tho√°t"]:
                print("üëã C·∫£m ∆°n b·∫°n ƒë√£ s·ª≠ d·ª•ng d·ªãch v·ª•!")
                break

            if not user_input:
                continue

            response = process_user_input(user_input)
            print(f"ü§ñ Bot: {response}\n")

        except KeyboardInterrupt:
            print("\nüëã T·∫°m bi·ªát!")
            break
        except Exception as e:
            logger.error(f"Unexpected error: {e}")
            print("‚ùå ƒê√£ x·∫£y ra l·ªói kh√¥ng mong mu·ªën. Vui l√≤ng th·ª≠ l·∫°i.")